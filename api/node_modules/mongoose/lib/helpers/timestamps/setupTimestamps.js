'use strict';

const applyTimestampsToChildren = require('../update/applyTimestampsToChildren');
const applyTimestampsToUpdate = require('../update/applyTimestampsToUpdate');
const get = require('../get');
const handleTimestampOption = require('../schema/handleTimestampOption');
<<<<<<< HEAD
=======
const setDocumentTimestamps = require('./setDocumentTimestamps');
>>>>>>> 895f4278cd300f98295191297723a8c0711282fe
const symbols = require('../../schema/symbols');

module.exports = function setupTimestamps(schema, timestamps) {
  const childHasTimestamp = schema.childSchemas.find(withTimestamp);
  function withTimestamp(s) {
    const ts = s.schema.options.timestamps;
    return !!ts;
  }

  if (!timestamps && !childHasTimestamp) {
    return;
  }

  const createdAt = handleTimestampOption(timestamps, 'createdAt');
  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');
  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?
    timestamps.currentTime :
    null;
  const schemaAdditions = {};

  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };

<<<<<<< HEAD
=======
  if (createdAt && !schema.paths[createdAt]) {
    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;
    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };
  }

>>>>>>> 895f4278cd300f98295191297723a8c0711282fe
  if (updatedAt && !schema.paths[updatedAt]) {
    schemaAdditions[updatedAt] = Date;
  }

<<<<<<< HEAD
  if (createdAt && !schema.paths[createdAt]) {
    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable: true };
  }
  schema.add(schemaAdditions);

  schema.pre('save', function(next) {
=======
  schema.add(schemaAdditions);

  schema.pre('save', function timestampsPreSave(next) {
>>>>>>> 895f4278cd300f98295191297723a8c0711282fe
    const timestampOption = get(this, '$__.saveOptions.timestamps');
    if (timestampOption === false) {
      return next();
    }

<<<<<<< HEAD
    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;

    const defaultTimestamp = currentTime != null ?
      currentTime() :
      this.ownerDocument().constructor.base.now();

    if (!skipCreatedAt && (this.isNew || this.$isSubdocument) && createdAt && !this.$__getValue(createdAt) && this.$__isSelected(createdAt)) {
      this.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });
    }

    if (!skipUpdatedAt && updatedAt && (this.isNew || this.$isModified())) {
      let ts = defaultTimestamp;
      if (this.isNew && createdAt != null) {
        ts = this.$__getValue(createdAt);
      }
      this.$set(updatedAt, ts);
    }
=======
    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
>>>>>>> 895f4278cd300f98295191297723a8c0711282fe

    next();
  });

  schema.methods.initializeTimestamps = function() {
    const ts = currentTime != null ?
      currentTime() :
      this.constructor.base.now();
    if (createdAt && !this.get(createdAt)) {
      this.$set(createdAt, ts);
    }
    if (updatedAt && !this.get(updatedAt)) {
      this.$set(updatedAt, ts);
    }
<<<<<<< HEAD
=======

    if (this.$isSubdocument) {
      return this;
    }

    const subdocs = this.$getAllSubdocs();
    for (const subdoc of subdocs) {
      if (subdoc.initializeTimestamps) {
        subdoc.initializeTimestamps();
      }
    }

>>>>>>> 895f4278cd300f98295191297723a8c0711282fe
    return this;
  };

  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;

  const opts = { query: true, model: false };
  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);
  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);
  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);
  schema.pre('update', opts, _setTimestampsOnUpdate);
  schema.pre('updateOne', opts, _setTimestampsOnUpdate);
  schema.pre('updateMany', opts, _setTimestampsOnUpdate);

  function _setTimestampsOnUpdate(next) {
    const now = currentTime != null ?
      currentTime() :
      this.model.base.now();
    // Replacing with null update should still trigger timestamps
    if (this.op === 'findOneAndReplace' && this.getUpdate() == null) {
      this.setUpdate({});
    }
    applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(),
      this.options, this.schema);
    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
    next();
  }
<<<<<<< HEAD
};
=======
};
>>>>>>> 895f4278cd300f98295191297723a8c0711282fe
